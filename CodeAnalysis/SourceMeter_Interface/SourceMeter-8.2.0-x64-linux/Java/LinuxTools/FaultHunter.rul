<?xml version="1.0" encoding="UTF-8"?>
<Rul xmlns = "http://www.frontendart.com" xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation = "http://www.frontendart.com rul.xsd">
  <ToolDescription>
    <Configuration name = "Default">
      <ToolDescriptionItem name = "ID">FaultHunter</ToolDescriptionItem>
    </Configuration>
  </ToolDescription>
  <Configurations/>
  <Views/>
  <Edges/>
  <Metric id = "Basic Rules">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Basic Rules</DisplayName>
        <Description>The Basic ruleset contains a collection of good practices which should be followed.</Description>
        <HelpText>The Basic ruleset contains a collection of good practices which should be followed.</HelpText>
        <WarningText>The Basic ruleset contains a collection of good practices which should be followed.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Brace Rules">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Brace Rules</DisplayName>
        <Description>The Braces ruleset contains rules regarding the use and placement of braces.</Description>
        <HelpText>The Braces ruleset contains rules regarding the use and placement of braces.</HelpText>
        <WarningText>The Braces ruleset contains rules regarding the use and placement of braces.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Code Size Rules">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Code Size Rules</DisplayName>
        <Description>The Code Size ruleset contains rules that find problems related to code size or complexity.</Description>
        <HelpText>The Code Size ruleset contains rules that find problems related to code size or complexity.</HelpText>
        <WarningText>The Code Size ruleset contains rules that find problems related to code size or complexity.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Controversial Rules">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Controversial Rules</DisplayName>
        <Description>The Controversial ruleset contains rules that, for whatever reason, are considered controversial. They are held here to allow people to include them as they see fit within their custom rulesets.</Description>
        <HelpText>The Controversial ruleset contains rules that, for whatever reason, are considered controversial. They are held here to allow people to include them as they see fit within their custom rulesets.</HelpText>
        <WarningText>The Controversial ruleset contains rules that, for whatever reason, are considered controversial. They are held here to allow people to include them as they see fit within their custom rulesets.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Design Rules">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Design Rules</DisplayName>
        <Description>The Design ruleset contains rules that flag suboptimal code implementations. Alternate approaches are suggested.</Description>
        <HelpText>The Design ruleset contains rules that flag suboptimal code implementations. Alternate approaches are suggested.</HelpText>
        <WarningText>The Design ruleset contains rules that flag suboptimal code implementations. Alternate approaches are suggested.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Empty Code Rules">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Empty Code Rules</DisplayName>
        <Description>The Empty Code ruleset contains rules that find empty statements of any kind (empty method, empty block statement, empty try or catch block,...).</Description>
        <HelpText>The Empty Code ruleset contains rules that find empty statements of any kind (empty method, empty block statement, empty try or catch block,...).</HelpText>
        <WarningText>The Empty Code ruleset contains rules that find empty statements of any kind (empty method, empty block statement, empty try or catch block,...).</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_ACNPE">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Strict Exception Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Avoid Catching NPE</DisplayName>
        <Description>Avoid catching NullPointerException; consider removing the cause of the NPE.</Description>
        <HelpText>&lt;p&gt;Code should never throw NullPointerExceptions under normal circumstances. A catch block may hide the original error, causing other, more subtle problems later on.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  void bar() {&#x0A;    try {&#x0A;    // do something&#x0A;    } catch (NullPointerException npe) {&#x0A;    &#x0A;    }&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid catching NullPointerException; consider removing the cause of the NPE.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Critical</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_ACT">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Strict Exception Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Avoid Catching Throwable</DisplayName>
        <Description>A catch statement should never catch throwable since it includes errors.</Description>
        <HelpText>&lt;p&gt;Catching Throwable errors is not recommended since its scope is very broad. It includes runtime issues such as OutOfMemoryError that should be exposed and managed separately.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public void bar() {&#x0A;  try {&#x0A;    // do something&#x0A;  } catch (Throwable th) { // should not catch Throwable&#x0A;    th.printStackTrace();&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>A catch statement should never catch throwable since it includes errors.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_ADNIS">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Avoid Deeply Nested If Stmts</DisplayName>
        <Description>Deeply nested if..then statements are hard to read.</Description>
        <HelpText>&lt;p&gt;Avoid creating deeply nested if-then statements since they are harder to read and error-prone to maintain.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  public void bar(int x, int y, int z) {&#x0A;    if (x &amp;gt; y) {&#x0A;      if (y &amp;gt; z) {&#x0A;        if (z == x) {&#x0A;          // !! too deep&#x0A;        }&#x0A;      }&#x0A;    }&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Deeply nested if..then statements are hard to read. They can make the source code less readable.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_AES">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Optimization Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Add Empty String</DisplayName>
        <Description>Do not add empty strings.</Description>
        <HelpText>&lt;p&gt;The conversion of literals to strings by concatenating them with empty strings is inefficient. It is much better to use one of the type-specific toString() methods instead.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;String s = &amp;quot;&amp;quot; + 123; // inefficient&#x0A;&#x0A;String t = Integer.toString(456); // preferred approach&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Do not add empty strings.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_AICICC">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Avoid Instanceof Checks In Catch Clause</DisplayName>
        <Description>An instanceof check is being performed on the caught exception.  Create a separate catch clause for this exception type.</Description>
        <HelpText>&lt;p&gt;Each caught exception type should be handled in its own catch clause.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;try { // Avoid this&#x0A;  // do something&#x0A;} catch (Exception ee) {&#x0A;  if (ee instanceof IOException) {&#x0A;    cleanup();&#x0A;  }&#x0A;}&#x0A;&#x0A;try { // Prefer this:&#x0A;  // do something&#x0A;} catch (IOException ee) {&#x0A;  cleanup();&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>An instanceof check is being performed on the caught exception.  Create a separate catch clause for this exception type.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_AIO">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Assignment In Operand</DisplayName>
        <Description>Avoid using assignment operators in operands.</Description>
        <HelpText>&lt;p&gt;Avoid Assignments in operands; this can make code more complicated and harder to read.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  public void bar(int x, int y, int z) {&#x0A;    if ((x = y) &amp;gt; 6) { // assignment operator in condition&#x0A;      z = 9;&#x0A;    }&#x0A;  }&#x0A;&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid using assignment operators in operands.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_AISD">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Security Code Guideline Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Array Is Stored Directly</DisplayName>
        <Description>The user-supplied array is stored directly.</Description>
        <HelpText>&lt;p&gt;Constructors and methods receiving arrays should clone objects and store the copy. This prevents future changes from the user from affecting the original array.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  private String [] x;&#x0A;  &#x0A;  public void foo (String [] param) {&#x0A;    // Don&apos;t do this, make a copy of the array at least&#x0A;    this.x=param;&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>The user-supplied array is stored directly.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_ALOC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <GroupMember>Controversial Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>At Least One Constructor</DisplayName>
        <Description>Each class should declare at least one constructor.</Description>
        <HelpText>Each class should declare at least one constructor.&lt;br&gt;Example(s):&lt;br&gt;&lt;pre class=&quot;sourcemeter-example-code&quot;&gt;&#x0A;  &#x0A;public class Foo {&#x0A;   // missing constructor&#x0A;  public void doSomething() { ... }&#x0A;  public void doOtherThing { ... }&#x0A;}&#x0A;  &#x0A;  &lt;/pre&gt;</HelpText>
        <WarningText>Each class should declare at least one constructor.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_APST">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Java Logging Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Avoid Print Stack Trace</DisplayName>
        <Description>Avoid printStackTrace(); use a logger call instead.</Description>
        <HelpText>&lt;p&gt;Avoid printStackTrace(); use a logger call instead.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;class Foo {&#x0A;&#x0A;  void bar() {&#x0A;    try {&#x0A;      // do something&#x0A;    } catch (Exception e) {&#x0A;      e.printStackTrace();&#x0A;    }&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid printStackTrace(); use a logger call instead.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_ARE">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Strict Exception Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Avoid Rethrowing Exception</DisplayName>
        <Description>A catch statement that catches an exception only to rethrow it should be avoided. In cases when the rethrowed exception can be caught by catches below are allowed.</Description>
        <HelpText>&lt;p&gt;Catch blocks that merely rethrow a caught exception only add to code size and runtime complexity. In cases when the rethrowed exception can be caught by following catches are allowed.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public void bar() {&#x0A;  try {&#x0A;    / do something&#x0A;  } catch (SomeException se) {&#x0A;    throw se;&#x0A;  }&#x0A;}&#x0A;&#x0A;public void foo(int a) throws IOException {&#x0A;  try {&#x0A;    if(a == 20) {&#x0A;      throw new IOException();&#x0A;    }&#x0A;  } catch (IOException e) {&#x0A;    throw e; // this is pointless&#x0A;  }&#x0A;}&#x0A;  &#x0A;  public void goo(int a) throws IOException {&#x0A;    try {&#x0A;      if(a == 20) {&#x0A;        throw new IOException();&#x0A;      } else {&#x0A;        throw new Eception();&#x0A;      }&#x0A;    } catch(IOException e) {&#x0A;      throw e; // it&apos;s OK, we don&apos;t want to catch the IOException here.&#x0A;    } catch(Exception e){&#x0A;    // do something&#x0A;    }&#x0A;  }&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>A catch statement that catches an exception only to rethrow it should be avoided.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_ATNPE">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Strict Exception Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Avoid Throwing Null Pointer Exception</DisplayName>
        <Description>Avoid throwing null pointer exceptions.</Description>
        <HelpText>&lt;p&gt;Avoid throwing NullPointerExceptions. These are confusing because most people will assume that the virtual machine threw it. Consider using an IllegalArgumentException instead; this will be clearly seen as a programmer-initiated exception. The rule also warns on null pointer exception instantiations.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  void bar() {&#x0A;    throw new NullPointerException();&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid throwing null pointer exceptions.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Critical</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_ATRET">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Strict Exception Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Avoid Throwing Raw Exception Types</DisplayName>
        <Description>Avoid throwing raw exception types, when you can use specialized types. The rule also warns on raw exception instantiaties.</Description>
        <HelpText>&lt;p&gt;Avoid throwing certain exception types. Rather than throw a raw RuntimeException, Throwable, Exception, or Error, use a subclassed exception or error instead. The rule also warns on raw exception instantiations.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  public void bar() throws Exception {&#x0A;    throw new Exception();&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid throwing raw exception types.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_BGMN">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Naming Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Boolean Get Method Name</DisplayName>
        <Description>A &apos;getX()&apos; method which returns a boolean should be named &apos;isX()&apos;.</Description>
        <HelpText>&lt;p&gt;Methods that return boolean results should be named as predicate statements to denote this. I.e, ‘isReady()’, ‘hasValues()’, ‘canCommit()’, ‘willFail()’, etc. Avoid the use of the ‘get’ prefix for these methods.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public boolean getFoo(); // bad&#x0A;&#x0A;public boolean isFoo(); // ok&#x0A;&#x0A;public boolean getFoo(boolean bar); // ok&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>A &apos;getX()&apos; method which returns a boolean should be named &apos;isX()&apos;.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_BI">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Basic Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Boolean Instantiation</DisplayName>
        <Description>Avoid instantiating Boolean objects; reference Boolean.TRUE or Boolean.FALSE or call Boolean.valueOf() instead.</Description>
        <HelpText>&lt;p&gt;Avoid instantiating Boolean objects; you can reference Boolean.TRUE, Boolean.FALSE, or call Boolean.valueOf() instead.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;Boolean bar = new Boolean(&amp;quot;true&amp;quot;); // unnecessary creation, just reference Boolean.TRUE;&#x0A;&#x0A;Boolean buz = Boolean.valueOf(false); // ..., just reference Boolean.FALSE;&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid instantiating Boolean objects.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_BII">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Basic Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Big Integer Instantiation</DisplayName>
        <Description>Don&apos;t create instances of already existing BigInteger and BigDecimal (ZERO, ONE, TEN).</Description>
        <HelpText>&lt;p&gt;Don’t create instances of already existing BigInteger (BigInteger.ZERO, BigInteger.ONE) and for Java 1.5 onwards, BigInteger.TEN and BigDecimal (BigDecimal.ZERO, BigDecimal.ONE, BigDecimal.TEN)&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;BigInteger bi = new BigInteger(1); // reference BigInteger.ONE instead&#x0A;&#x0A;BigInteger bi2 = new BigInteger(&amp;quot;0&amp;quot;); // reference BigInteger.ZERO instead&#x0A;&#x0A;BigInteger bi3 = new BigInteger(0.0); // reference BigInteger.ZERO instead&#x0A;&#x0A;BigInteger bi4;&#x0A;&#x0A;bi4 = new BigInteger(0); // reference BigInteger.ZERO instead&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Don&apos;t create instances of already existing BigInteger and BigDecimal (ZERO, ONE, TEN).</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_ByI">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Migration Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Byte Instantiation</DisplayName>
        <Description>Avoid instantiating Byte objects. Call Byte.valueOf() instead.</Description>
        <HelpText>&lt;p&gt;Calling new Byte() causes memory allocation that can be avoided by the static Byte.valueOf(). It makes use of an internal cache that recycles earlier instances making it more memory efficient.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  private Byte i = new Byte(0); // change to Byte i = Byte.valueOf(0);&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid instantiating Byte objects. Call Byte.valueOf() instead.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_CC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <GroupMember>Code Size Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Cyclomatic Complexity</DisplayName>
        <Description>The method has greater Cyclomatic Complexity than the limit.</Description>
        <HelpText>Complexity of the method expressed as the number of independent control flow paths in it. It represents a lower bound for the number of possible execution paths in the source code and at the same time it is an upper bound for the minimum number of test cases needed for achieving full branch test coverage. The value of the metric is initially 1 which increases by 1 for each occurence of the following instructions: if, for, foreach, while, do-while, case label (label that belongs to a switch instruction), catch (handler that belongs to a try block), conditional statement (?:). Moreover, logical and (&amp;&amp;) and logical or (||) expressions also add to the final value because their short-circuit evalutaion can cause branching depending on the first operand. The following language elements do not increase the value: else, try, switch, default label (default label that belongs to a switch instruction), finally.&lt;br&gt;Example(s):&lt;br&gt;&lt;pre class=&quot;sourcemeter-example-code&quot;&gt;&#x0A;&#x0A;public class Foo {&#x09;&#x09;// This has a Cyclomatic Complexity = 11&#x0A;1   public void example()  {&#x0A;2       if (a == b)  {&#x0A;3           if (a1 == b1) {&#x0A;                fiddle();&#x0A;4           } else if a2 == b2) {&#x0A;                fiddle();&#x0A;            }  else {&#x0A;                fiddle();&#x0A;            }&#x0A;5       } else if (c == d) {&#x0A;6           while (c == d) {&#x0A;                fiddle();&#x0A;            }&#x0A;7        } else if (e == f) {&#x0A;8           for (int n = 0; n &lt; h; n++) {&#x0A;                fiddle();&#x0A;            }&#x0A;        } else{&#x0A;            switch (z) {&#x0A;9               case 1:&#x0A;                    fiddle();&#x0A;                    break;&#x0A;10              case 2:&#x0A;                    fiddle();&#x0A;                    break;&#x0A;11              case 3:&#x0A;                    fiddle();&#x0A;                    break;&#x0A;                default:&#x0A;                    fiddle();&#x0A;                    break;&#x0A;            }&#x0A;        }&#x0A;    }&#x0A;}&#x0A;&#x0A;   &lt;/pre&gt;</HelpText>
        <WarningText>The method has greater Cyclomatic Complexity than the limit.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_COWE">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Compare Objects With Equals</DisplayName>
        <Description>Use equals() to compare object references.</Description>
        <HelpText>Use equals() to compare object references; avoid comparing them with == or !=.&lt;br&gt;Example(s):&lt;br&gt;&lt;pre class=&quot;sourcemeter-example-code&quot;&gt;&#x0A;&#x0A;class Foo {&#x0A;  boolean bar(String a, String b) {&#x0A;    return a == b;&#x0A;  }&#x0A;}&#x0A;&#x0A;&#x0A;  &lt;/pre&gt;</HelpText>
        <WarningText>Use equals() to compare object references.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Critical</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_ClR">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Close Resource</DisplayName>
        <Description>Ensure that all resources object are closed after use.</Description>
        <HelpText>&lt;p&gt;Ensure that resources (like Connection, Statement, and ResultSet objects) are always closed in a finally block after use.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Bar {&#x0A;&#x0A;  public void foo() {&#x0A;    Connection c = pool.getConnection();&#x0A;    try {&#x0A;      // do stuff&#x0A;    } catch (SQLException ex) {&#x0A;      // handle exception&#x0A;    } finally {&#x0A;      // oops, should close the connection using &apos;close&apos;!&#x0A;      // c.close();&#x0A;    }&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Ensure that all resources object are closed after use.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Critical</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_DLNLISS">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Default Label Not Last In Switch Stmt</DisplayName>
        <Description>The default label should be the last label in a switch statement.</Description>
        <HelpText>&lt;p&gt;By convention, the default label should be the last label in a switch statement.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  void bar(int a) {&#x0A;    switch (a) {&#x0A;      case 1: // do something&#x0A;        break;&#x0A;      default: // the default case should be last, by convention&#x0A;        break;&#x0A;      case 2:&#x0A;        break;&#x0A;    }&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>The default label should be the last label in a switch statement.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_DNCRE">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Do not Call Runtime exec</DisplayName>
        <Description>Do not Call Runtime exec.</Description>
        <HelpText>&lt;p&gt;Runtime.exec() should not be invoked.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;  void executeCommand(String command) {&#x0A;    Process process = Runtime.getRuntime().exec(command);&#x0A;    // ...&#x0A;  }&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Do not Call Runtime exec</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_DNCTIEJB">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Do not Create Threads in EJB</DisplayName>
        <Description>Do not Create Threads in EJB.</Description>
        <HelpText>&lt;p&gt;The enterprise bean must not attempt to manage threads because it would harm resource management and transaction management.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;@Stateless&#x0A;public class Example {&#x0A;  void threadExample() {&#x0A;    Thread t = new Thread();&#x0A;    t.run();  // never call Thread.run() in EJB&#x0A;    t.start();  // never call Thread.start() in EJB&#x0A;  }&#x0A;  &#x0A;  void runnableExample() {&#x0A;    Runnable r = new Runnable() {&#x0A;      public void run() {&#x0A;        // ...&#x0A;      }&#x0A;    };&#x0A;    r.run();  // never call Runnable.run() in EJB&#x0A;  }&#x0A;  &#x0A;  void callableExample() throws Exception {&#x0A;    Callable&amp;lt;Integer&amp;gt; c = new Callable&amp;lt;Integer&amp;gt;() {&#x0A;      public Integer call() throws Exception {&#x0A;        // ...&#x0A;      }&#x0A;    };&#x0A;    c.call();  // never call Callable&amp;lt;T&amp;gt;.call() in EJB&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Do not Create Threads in EJB</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_DNULFIEJB">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Do not Use Local Files in EJB</DisplayName>
        <Description>Do not Use Local Files in EJB</Description>
        <HelpText>&lt;p&gt;java.io.Reader, java.io.InputStream, java.nio.file.Files and javax.imageio.stream.FileImageInputStream should not be used in enterprise bean to access local files.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;@Remote&#x0A;public class Example {&#x0A;  void foo() {&#x0A;    Reader reader = new StringReader(&amp;quot;input.txt&amp;quot;);&#x0A;    // ...&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Do not Use Local Files in EJB</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_DNUNQA">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Do Not Use NamedQuery Annotation</DisplayName>
        <Description>Do Not Use NamedQuery Annotation</Description>
        <HelpText>&lt;p&gt;NamedQuery annotations should not be used.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;@NamedQuery(&#x0A;    name=&amp;quot;findAllEmployee&amp;quot;,&#x0A;    queryString=&amp;quot;SELECT * FROM Employee&amp;quot;&#x0A;)&#x0A;public class Employee {&#x0A;  // ...&#x0A;}&#x0A;&#x0A;&#x0A;@NamedQueries({&#x0A;  @NamedQuery(name=&amp;quot;Student.findAll&amp;quot;,&#x0A;              query=&amp;quot;SELECT s FROM Student s&amp;quot;),&#x0A;  @NamedQuery(name=&amp;quot;Student.findByName&amp;quot;,&#x0A;              query=&amp;quot;SELECT s FROM Student s WHERE s.name = :name&amp;quot;)&#x0A;})&#x0A;public class Student {&#x0A;  // ...&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Do Not Use NamedQuery Annotation</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_DNUSIEJB">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Do not Use Synchronized in EJB</DisplayName>
        <Description>Do not Use Synchronized in EJB.</Description>
        <HelpText>&lt;p&gt;Neither method nor block level synchronization should be used in enterprise bean.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;@Stateless&#x0A;class Example {&#x0A;  &#x0A;  public synchronized void foo() {&#x0A;    // ...&#x0A;  }&#x0A;&#x0A;  public void goo() {&#x0A;    synchronized(this) {&#x0A;      // ...&#x0A;    }&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Do not Use Synchronized in EJB</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_ECB">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Basic Rules</GroupMember>
      <GroupMember>Empty Code Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Empty Catch Block</DisplayName>
        <Description>Avoid empty catch blocks.</Description>
        <HelpText>&lt;p&gt;Empty Catch Block finds instances where an exception is caught, but nothing is done, except if there is a comment in the code. In most circumstances, this swallows an exception which should either be acted on or reported.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public void doSomething() {&#x0A;  try {&#x0A;  FileInputStream fis = new FileInputStream(&amp;quot;/tmp/bugger&amp;quot;);&#x0A;  } catch (IOException ioe) {&#x0A;&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid empty catch blocks.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Critical</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_EFB">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Basic Rules</GroupMember>
      <GroupMember>Empty Code Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Empty Finally Block</DisplayName>
        <Description>Avoid empty finally blocks.</Description>
        <HelpText>&lt;p&gt;Empty finally blocks serve no purpose and should be removed.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  public void bar() {&#x0A;    try {&#x0A;    int x=2;&#x0A;    } finally {&#x0A;    // empty!&#x0A;    }&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid empty finally blocks.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_EIS">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Basic Rules</GroupMember>
      <GroupMember>Empty Code Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Empty If Stmt</DisplayName>
        <Description>Avoid empty &apos;if&apos; statements.</Description>
        <HelpText>&lt;p&gt;Empty If Statement finds instances where a condition is checked but nothing is done about it.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  void bar(int x) {&#x0A;    if (x == 0) {&#x0A;    // empty!&#x0A;    }&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid empty &apos;if&apos; statements.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_EML">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <GroupMember>Code Size Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Excessive Method Length</DisplayName>
        <Description>Avoid really long methods.</Description>
        <HelpText>When methods are excessively long this usually indicates that the method is doing more than its name/signature might suggest. They also become challenging for others to digest since excessive scrolling causes readers to lose focus. Try to reduce the method length by creating helper methods and removing any copy/pasted code.&lt;br&gt;Example(s):&lt;br&gt;&lt;pre class=&quot;sourcemeter-example-code&quot;&gt;&#x0A;&#x0A;public void doSomething() {&#x0A;&#x09;System.out.println(&quot;Hello world!&quot;);&#x0A;&#x09;System.out.println(&quot;Hello world!&quot;);&#x0A;&#x09;&#x09;// 98 copies omitted for brevity.&#x0A;}&#x0A;&#x0A;&#x0A;   &lt;/pre&gt;</HelpText>
        <WarningText>Avoid really long methods.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_EMRC">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Equal Method Returns Constant</DisplayName>
        <Description>Avoid using equals() methods with a constant return value.</Description>
        <HelpText>&lt;p&gt;Do not use equals() methods with a constant return value. These are potentially unfinished methods.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;@Override&#x0A;public boolean equals(Object arg) {&#x0A;  return true; // returns with constant&#x0A;}&#x0A;}&#x0A;&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid using equals() methods with a constant return value.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_EOB">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Empty Code Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Empty Override Block</DisplayName>
        <Description>An empty method should not be overridden by another empty method.</Description>
        <HelpText>&lt;p&gt;Do not override an empty method with another empty method. It is useless.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  public void bar() {&#x0A;  &#x0A;  }&#x0A;  &#x0A;}&#x0A;&#x0A;public class Child extends Foo{&#x0A;&#x0A;  @Override&#x0A;  public void bar() { // empty override block&#x0A;&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>An empty method should not be overridden by another empty method.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_ESB">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Basic Rules</GroupMember>
      <GroupMember>Empty Code Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Empty Synchronized Block</DisplayName>
        <Description>Avoid empty synchronized blocks.</Description>
        <HelpText>&lt;p&gt;Empty synchronized blocks serve no purpose and should be removed.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  public void bar() {&#x0A;    synchronized (this) {&#x0A;    // empty!&#x0A;    }&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid empty synchronized blocks.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_ESS">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Basic Rules</GroupMember>
      <GroupMember>Empty Code Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Empty Switch Statements</DisplayName>
        <Description>Avoid empty switch statements.</Description>
        <HelpText>&lt;p&gt;Empty switch statements serve no purpose and should be removed.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public void bar() {&#x0A;  int x = 2;&#x0A;  switch (x) {&#x0A;    // once there was code here&#x0A;    // but it&apos;s been commented out or something&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid empty switch statements.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_ETB">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Basic Rules</GroupMember>
      <GroupMember>Empty Code Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Empty Try Block</DisplayName>
        <Description>Avoid empty try blocks.</Description>
        <HelpText>&lt;p&gt;Avoid empty try blocks - what’s the point?&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  public void bar() {&#x0A;    try {&#x0A;    &#x0A;    } catch (Exception e) {&#x0A;    e.printStackTrace();&#x0A;    }&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid empty try blocks.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_EWS">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Basic Rules</GroupMember>
      <GroupMember>Empty Code Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Empty While Stmt</DisplayName>
        <Description>Avoid empty &apos;while&apos; statements.</Description>
        <HelpText>&lt;p&gt;Empty While Statement finds all instances where a while statement does nothing. If it is a timing loop, then you should use Thread.sleep() for it; if it is a while loop that does a lot in the condition expression (increase, decrease, assign or call a method), no warning is issued.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;void bar(int a, int b) {&#x0A;  while (a == b) {&#x0A;    // empty!&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid empty &apos;while&apos; statements.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Critical</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_FLMUB">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Brace Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>For Loops Must Use Braces</DisplayName>
        <Description>Avoid using &apos;for&apos; statements without curly braces.</Description>
        <HelpText>&lt;p&gt;Avoid using ‘for’ statements without using curly braces. If the code formatting or indentation is lost then it becomes difficult to separate the code being controlled from the rest.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;for (int i = 0; i &amp;lt; 42; i++)&#x0A;  foo();&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid using &apos;for&apos; statements without curly braces.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_HF">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Hide Field</DisplayName>
        <Description>Reach fields via getter/setter functions, not by direct reference</Description>
        <HelpText>&lt;p&gt;Reach fields via getter/setter functions, not by direct reference.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  public int i;&#x0A;&#x0A;}&#x0A;&#x0A;class Bar {&#x0A;&#x0A;  public void example() {&#x0A;    Foo f = new Foo();&#x0A;    int z = f.i; // should be accessed via a getter&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Reach fields via getter/setter functions, not by direct reference</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_IESMUB">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Brace Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>If Else Stmts Must Use Braces</DisplayName>
        <Description>Avoid using &apos;if...else&apos; statements without curly braces.</Description>
        <HelpText>&lt;p&gt;Avoid using if or if..else statements without using surrounding braces. If the code formatting or indentation is lost then it becomes difficult to separate the code being controlled from the rest.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;if (foo)&#x0A;  x = x+1;&#x0A;else&#x0A;  x = x-1;&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid using &apos;if...else&apos; statements without curly braces.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_II">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Migration Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Integer Instantiation</DisplayName>
        <Description>Avoid instantiating Integer objects. Call Integer.valueOf() instead.</Description>
        <HelpText>&lt;p&gt;Calling new Integer() causes memory allocation that can be avoided by the static Integer.valueOf(). It makes use of an internal cache that recycles earlier instances making it more memory efficient.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  private Integer i = new Integer(0);&#x0A;  // change to Integer i = Integer.valueOf(0);&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid instantiating Integer objects. Call Integer.valueOf() instead.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_LVCBF">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <GroupMember>Optimization Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Local Variable Could Be Final</DisplayName>
        <Description>Local variable could be declared final.</Description>
        <HelpText>A local variable assigned only once can be declared final.&lt;br&gt;Example(s):&lt;br&gt;&lt;pre class=&quot;sourcemeter-example-code&quot;&gt;&#x0A;  &#x0A;public class Bar {&#x0A;&#x09;public void foo () {&#x0A;&#x09;&#x09;String txtA = &quot;a&quot;; &#x09;&#x09;// if txtA will not be assigned again it is better to do this:&#x0A;&#x09;&#x09;final String txtB = &quot;b&quot;;&#x0A;&#x09;}&#x0A;}&#x0A;  &#x0A;      &lt;/pre&gt;</HelpText>
        <WarningText>Local variable could be declared final.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_LoC">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Type Resolution Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Loose Coupling</DisplayName>
        <Description>Avoid using concrete implementation types. Use its interface instead.</Description>
        <HelpText>&lt;p&gt;Avoid using implementation types (i.e., HashSet); use the interface (i.e, Set) instead.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;import java.util.ArrayList;&#x0A;import java.util.HashSet;&#x0A;&#x0A;public class Bar {&#x0A;  // Use List instead&#x0A;  private ArrayList list = new ArrayList();&#x0A;  &#x0A;  // Use Set instead&#x0A;  public HashSet getFoo() {&#x0A;    return new HashSet();&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid using concrete implementation types. Use its interface instead.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_LoI">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Migration Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Long Instantiation</DisplayName>
        <Description>Avoid instantiating Long objects.Call Long.valueOf() instead.</Description>
        <HelpText>&lt;p&gt;Calling new Long() causes memory allocation that can be avoided by the static Long.valueOf(). It makes use of an internal cache that recycles earlier instances making it more memory efficient.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  private Long i = new Long(0); // change to Long i = Long.valueOf(0);&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid instantiating Long objects.Call Long.valueOf() instead.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_MBIS">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Missing Break In Switch</DisplayName>
        <Description>A switch statement does not contain a break.</Description>
        <HelpText>&lt;p&gt;Switch statements without break, continue, throw or return statements for each case branch may indicate problematic behaviour. Empty cases are ignored as these indicate an intentional fall-through. When the case branch ends with a comment with ‘fall-through’ content are ignored as well. Missing break in the last case branch does not cause any problem so it is also ignored.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public void bar(int status) {&#x0A;  switch(status) {&#x0A;    case CANCELLED:&#x0A;      doCancelled();&#x0A;      // break; hm, should this be commented out?&#x0A;    case NEW:&#x0A;      doNew();&#x0A;      // is this really a fall-through?&#x0A;    case REMOVED:&#x0A;      doRemoved();&#x0A;      // what happens if you add another case after this one?&#x0A;    case OTHER: // empty case - this is interpreted as an intentional&#x0A;      // fall-through&#x0A;    case ERROR:&#x0A;      doErrorHandling();&#x0A;      break;&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>A switch statement does not contain a break.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Critical</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_MNCTS">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Missing Null Check In ToString</DisplayName>
        <Description>Avoid using an object&apos;s members in toString methods without checking whether the object is null.</Description>
        <HelpText>&lt;p&gt;Avoid using an object’s members in toString methods without checking whether the object is null. A null check may be required to avoid NullPointerException.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  private Object o;&#x0A;&#x0A;  @Override&#x0A;  public String toString() {&#x0A;    return o.toString(); // missing null check&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid using an object&apos;s members in toString methods without checking whether the object is null.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_MWSNAEC">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Naming Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Method With Same Name As Enclosing Class</DisplayName>
        <Description>Classes should not have non-constructor methods with the same name as the class.</Description>
        <HelpText>&lt;p&gt;Non-constructor methods should not have the same name as the enclosing class.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class MyClass {&#x0A;&#x0A;  public MyClass() {} // this is OK because it is a constructor&#x0A;  public void MyClass() {} // this is bad because it is a method&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Classes should not have non-constructor methods with the same name as the class.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_MeNC">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Naming Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Method Naming Conventions</DisplayName>
        <Description>Method name does not begin with a lower case character.</Description>
        <HelpText>&lt;p&gt;Method names should always begin with a lower case character, and should not contain underscores.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  public void fooStuff() {&#x0A;&#x0A;  }&#x0A;&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Method name does not begin with a lower case character.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_NFSVMBSB">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Non Final Static Variable Must Be In Synchronized Block</DisplayName>
        <Description>Non-constant static variable must be used in synchronized block or method.</Description>
        <HelpText>&lt;p&gt;Non-constant static variable must be used in synchronized block or method.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  public static int a;&#x0A;&#x0A;  public void bar() { // should be synchronized&#x0A;    if (a == 0){&#x0A;      a = 10;&#x0A;    }&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Non-constant static variable must be used in synchronized block or method.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_NPC">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <GroupMember>Code Size Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>NPath Complexity</DisplayName>
        <Description>The method has greater NPath complexity than the limit.</Description>
        <HelpText>The NPath complexity of a method is the number of acyclic execution paths through that method. A threshold of 200 is generally considered the point where measures should be taken to reduce complexity and increase readability.&lt;br&gt;Example(s):&lt;br&gt;&lt;pre class=&quot;sourcemeter-example-code&quot;&gt;&#x0A; &#x0A;void bar() {&#x09;// this is something more complex than it needs to be,&#x0A;&#x09;if (y) {&#x09;// it should be broken down into smaller methods or functions&#x0A;&#x09;&#x09;for (j = 0; j &lt; m; j++) {&#x0A;&#x09;&#x09;&#x09;if (j &gt; r) {&#x0A;&#x09;&#x09;&#x09;&#x09;doSomething();&#x0A;&#x09;&#x09;&#x09;&#x09;while (f &lt; 5 ) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;anotherThing();&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;f -= 27;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;tryThis();&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x09;&#x09;if ( r - n &gt; 45) {&#x0A;&#x09;&#x09;   while (doMagic()) {&#x0A;&#x09;&#x09;      findRabbits();&#x0A;&#x09;&#x09;   }&#x0A;&#x09;&#x09;}&#x0A;&#x09;&#x09;try {&#x0A;&#x09;&#x09;&#x09;doSomethingDangerous();&#x0A;&#x09;&#x09;} catch (Exception ex) {&#x0A;&#x09;&#x09;&#x09;makeAmends();&#x0A;&#x09;&#x09;&#x09;} finally {&#x0A;&#x09;&#x09;&#x09;&#x09;dontDoItAgain();&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x09;}&#x0A;}&#x0A;&#x0A; &#x0A;    &lt;/pre&gt;</HelpText>
        <WarningText>The method has greater NPath complexity than the limit.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_PLFIC">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Position Literals First In Comparisons</DisplayName>
        <Description>Position literals first in String comparisons. Marks cases when the equals parameter is a static final String constant.</Description>
        <HelpText>&lt;p&gt;Position literals (or static final variables) first in comparisons, if the second argument is null then NullPointerExceptions can be avoided, they will just return false.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;class Foo {&#x0A;&#x0A;  private static final String OK_BUTTON = &amp;quot;OK&amp;quot;;&#x0A;&#x0A;  boolean bar(String x) {&#x0A;    return x.equals(&amp;quot;2&amp;quot;); // should be &amp;quot;2&amp;quot;.equals(x)&#x0A;  }&#x0A;&#x0A;  boolean isOK(String x) {&#x0A;    return x.equals(OK_BUTTON); // should be OK_BUTTON.equals(x)&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Position literals first in String comparisons.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Critical</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_PLFICIC">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Position Literals First In Case Insensitive Comparisons</DisplayName>
        <Description>Position literals first in String comparisons for EqualsIgnoreCase</Description>
        <HelpText>&lt;p&gt;Position literals (or static final variables) first in comparisons, if the second argument is null then NullPointerExceptions can be avoided, they will just return false.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;class Foo {&#x0A;&#x0A;  private static final String OK_BUTTON = &amp;quot;OK&amp;quot;;&#x0A;&#x0A;  boolean bar(String x) {&#x0A;    // should be &amp;quot;Bar&amp;quot;.equalsIgnoreCase(x)&#x0A;    return x.equalsIgnoreCase(&amp;quot;Bar&amp;quot;);&#x0A;  }&#x0A;&#x0A;  boolean isOK(String x) {&#x0A;    // should be OK_BUTTON.equalsIgnoreCase(x)&#x0A;    return x.equalsIgnoreCase(OK_BUTTON);&#x0A;  }&#x0A;&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Position literals first in String comparisons for EqualsIgnoreCase</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Critical</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_PST">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Preserve Stack Trace</DisplayName>
        <Description>New exception is thrown in catch block, original stack trace may be lost.</Description>
        <HelpText>&lt;p&gt;Throwing a new exception from a catch block without passing the original exception into the new exception will cause the original stack trace to be lost making it difficult to debug effectively.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  void good() {&#x0A;    try{&#x0A;      Integer.parseInt(&amp;quot;a&amp;quot;);&#x0A;    } catch (Exception e) {&#x0A;      throw new Exception(e); // first possibility to create&#x0A;      // exception chain&#x0A;    }&#x0A;    try {&#x0A;      Integer.parseInt(&amp;quot;a&amp;quot;);&#x0A;    } catch (Exception e) {&#x0A;    throw (IllegalStateException)new IllegalStateException()&#x0A;      .initCause(e);// second possibility to create exception chain.&#x0A;    }&#x0A;  }&#x0A;  &#x0A;  void bad() {&#x0A;    try{&#x0A;      Integer.parseInt(&amp;quot;a&amp;quot;);&#x0A;    } catch (Exception e) {&#x0A;      throw new Exception(e.getMessage()); // loosing the stack trace!&#x0A;    }&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>New exception is thrown in catch block, original stack trace may be lost.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_RHWM">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Migration Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Replace Hashtable With Map</DisplayName>
        <Description>Consider replacing this Hashtable with the newer java.util.Map.</Description>
        <HelpText>&lt;p&gt;Consider replacing Hashtable usage with the newer java.util.Map if thread safety is not required.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  void bar() {&#x0A;    Hashtable h = new Hashtable();&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Consider replacing this Hashtable with the newer java.util.Map.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_RVWL">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Migration Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Replace Vector With List</DisplayName>
        <Description>Consider replacing this Vector with the newer java.util.List.</Description>
        <HelpText>&lt;p&gt;Consider replacing Vector usages with the newer java.util.ArrayList if expensive thread-safe operations are not required.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  void bar() {&#x0A;    Vector v = new Vector();&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Consider replacing this Vector with the newer java.util.List.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_SC">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Simplify Conditional</DisplayName>
        <Description>No need to check for null before an instanceof.</Description>
        <HelpText>&lt;p&gt;No need to check for null before an instanceof; the instanceof keyword returns false when given a null argument.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;class Foo {&#x0A;&#x0A;  void bar(Object x) {&#x0A;    if (x != null &amp;amp;&amp;amp; x instanceof Bar) {&#x0A;      // just drop the &amp;quot;x != null&amp;quot; check&#x0A;    }&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>No need to check for null before an instanceof.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_SDFNL">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Simple Date Format Needs Locale</DisplayName>
        <Description>When instantiating a SimpleDateFormat object, specify a Locale.</Description>
        <HelpText>&lt;p&gt;Be sure to specify a Locale when creating java.text.SimpleDateFormat instances to ensure that locale-appropriate formatting is used.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  // Should specify Locale.US (or whatever)&#x0A;  private SimpleDateFormat sdf = new SimpleDateFormat(&amp;quot;pattern&amp;quot;);&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>When instantiating a SimpleDateFormat object, specify a Locale.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_SHMN">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Naming Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Suspicious Hashcode Method Name</DisplayName>
        <Description>The method name and return type are suspiciously close to hashCode().</Description>
        <HelpText>&lt;p&gt;The method name and return type are suspiciously close to hashCode(), which may denote an intention to override the hashCode() method.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  public int hashcode() { &#x0A;    // oops, this probably was&#x0A;    // supposed to be &apos;hashCode&apos;&#x0A;  }&#x0A;&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>The method name and return type are suspiciously close to hashCode().</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Critical</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_SI">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Migration Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Short Instantiation</DisplayName>
        <Description>Avoid instantiating Short objects. Call Short.valueOf() instead.</Description>
        <HelpText>&lt;p&gt;Calling new Short() causes memory allocation that can be avoided by the static Short.valueOf(). It makes use of an internal cache that recycles earlier instances making it more memory efficient.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  private Short i = new Short(0); // change to Short i = Short.valueOf(0);&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid instantiating Short objects. Call Short.valueOf() instead.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_SMN">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Naming Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Short Method Name</DisplayName>
        <Description>Avoid using short method names.</Description>
        <HelpText>&lt;p&gt;Method names that are very short are not helpful to the reader. Names like ‘or’, ‘in’, ‘lt’, ‘gt’, ‘eq’, ‘le’, ‘ge’, ‘ne’ are allowed.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class ShortMethod {&#x0A;&#x0A;  public void a( int i ) { // Violation&#x0A;&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid using short method names.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_SP">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Java Logging Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>System Println</DisplayName>
        <Description>System.out.print is used</Description>
        <HelpText>&lt;p&gt;Printing to System.(out|err) is usually intended for debugging purposes and should not remain in the code.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  Logger log = Logger.getLogger(Foo.class.getName());&#x0A;&#x0A;  public void testA() {&#x0A;&#x0A;    System.out.println(&amp;quot;Entering&amp;quot;);&#x0A;&#x0A;    // Better use this&#x0A;&#x0A;    log.info(&amp;quot;Entering&amp;quot;);&#x0A;&#x0A;  }&#x0A;&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>System.(out|err).print is used</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_SSSHD">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Switch Stmts Should Have Default</DisplayName>
        <Description>Switch statements should have a default label.</Description>
        <HelpText>&lt;p&gt;All switch statements should include a default option to catch any unspecified values.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public void bar() {&#x0A;  int x = 2;&#x0A;  switch (x) {&#x0A;  case 1: int j = 6;&#x0A;  case 2: int j = 8;&#x0A;    // missing default: here&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Switch statements should have a default label.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_TMM">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <GroupMember>Code Size Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Too Many Methods</DisplayName>
        <Description>This class has too many methods, consider refactoring it.</Description>
        <HelpText>A class with too many methods is probably a good suspect for refactoring, in order to reduce its complexity and find a way to have more fine grained objects.</HelpText>
        <WarningText>This class has too many methods, consider refactoring it.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_TMR">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Too Many Returns</DisplayName>
        <Description>Avoid using more than one return statements in a method.</Description>
        <HelpText>&lt;p&gt;Do not use more than one return statement in a method. Too many return statements can make a method less understandable.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  public void bar(int x, int y, int z) { // too many returns&#x0A;    if (x &amp;gt; y &amp;amp;&amp;amp; x &amp;gt; z) {&#x0A;      return x;&#x0A;    } else if (y &amp;gt; x &amp;amp;&amp;amp; y &amp;gt; z) {&#x0A;      return y;&#x0A;    } else {&#x0A;      return z;&#x0A;    }&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid using more than one return statements in a method.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_UALIOV">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Optimization Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Use Array List Instead Of Vector</DisplayName>
        <Description>Use ArrayList instead of Vector.</Description>
        <HelpText>&lt;p&gt;ArrayList is a much better Collection implementation than Vector if thread-safe operation is not required.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class SimpleTest extends TestCase {&#x0A;&#x0A;  public void testX() {&#x0A;    Collection c1 = new Vector();&#x0A;    Collection c2 = new ArrayList(); // achieves the same&#x0A;    // with much better performance&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Use ArrayList instead of Vector.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_UEM">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Uncommented Empty Method</DisplayName>
        <Description>Document empty method.</Description>
        <HelpText>&lt;p&gt;Uncommented Empty Method finds instances where a method does not contain statements, but there is no comment. By explicitly commenting empty methods it is easier to distinguish between intentional (commented) and unintentional empty methods.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public void doSomething() {&#x0A;&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Document empty method.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_UETCS">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>String and StringBuffer Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Use Equals To Compare Strings</DisplayName>
        <Description>Use equals() to compare strings instead of &apos;&apos;==&apos;&apos; or &apos;&apos;!=&apos;&apos;.</Description>
        <HelpText>&lt;p&gt;Using ‘==’ or ‘!=’ to compare strings only works if intern version is used on both sides. Use the equals() method instead.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public boolean test(String s) {&#x0A;  if (s == &amp;quot;one&amp;quot;) return true; // unreliable&#x0A;  if (&amp;quot;two&amp;quot;.equals(s)) return true; // better&#x0A;  return false;&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Using the == or != operator is compare the objects with theirs reference. It causes compare beetween two String with equal content returns false.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Critical</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_ULBR">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Unnecessary Local Before Return</DisplayName>
        <Description>Consider simply returning the value vs storing it in a local variable.</Description>
        <HelpText>&lt;p&gt;Consider simply returning the value vs storing it in a local variable.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  public int foo() {&#x0A;    int x = doSomething();&#x0A;    return x; // instead, just &apos;return doSomething();&apos;&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Consider simply returning the value vs storing it in a local variable.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_ULV">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Unnecessary and Unused Code Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Unused Local Variable</DisplayName>
        <Description>Avoid unused local variables.</Description>
        <HelpText>&lt;p&gt;Detects when a local variable is just declared, but not used.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  public void doSomething() {&#x0A;    int i = 5; // Unused&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid unused local variables.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_ULWCC">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Design Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Use Locale With Case Conversions</DisplayName>
        <Description>When doing a String.toLowerCase()/toUpperCase() call, use a Locale.</Description>
        <HelpText>&lt;p&gt;When doing String.toLowerCase()/toUpperCase() conversions, use Locales to avoid problems with languages that have unusual conventions, i.e. Turkish.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;class Foo {&#x0A;  // BAD&#x0A;  if (x.toLowerCase().equals(&amp;quot;list&amp;quot;))...&#x0A;  // This will not match &amp;quot;LIST&amp;quot; when in Turkish locale&#x0A;  // The above could be&#x0A;  // if (x.toLowerCase(Locale.US).equals(&amp;quot;list&amp;quot;)) ...&#x0A;  // or simply&#x0A;  // if (x.equalsIgnoreCase(&amp;quot;list&amp;quot;)) ...&#x0A;  // GOOD&#x0A;&#x0A;  String z = a.toLowerCase(Locale.EN);&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>When doing a String.toLowerCase()/toUpperCase() call, use a Locale.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Critical</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_UOM">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Basic Rules</GroupMember>
      <GroupMember>Unnecessary and Unused Code Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Useless Overriding Method</DisplayName>
        <Description>Overriding method merely calls super</Description>
        <HelpText>&lt;p&gt;The overriding method merely calls the same method defined in a superclass.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public void foo(String bar) {&#x0A;  super.foo(bar); // why bother overriding?&#x0A;}&#x0A;&#x0A;public String foo() {&#x0A;  return super.foo(); // why bother overriding?&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid method which only calls the method it overrides.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_UPF">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Unnecessary and Unused Code Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Unused Private Field</DisplayName>
        <Description>Avoid unused private fields.</Description>
        <HelpText>&lt;p&gt;Detects when a private field is just declared, but not used.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Something {&#x0A;&#x0A;  private static int FOO = 2; // Unused&#x0A;  private int i = 5; // Unused&#x0A;  private int j = 6;&#x0A;  &#x0A;  public int addOne() {&#x0A;    return j++;&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid unused private fields.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_UPM">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Unnecessary and Unused Code Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Unused Private Method</DisplayName>
        <Description>Avoid unused private methods.</Description>
        <HelpText>&lt;p&gt;&lt;b&gt;Unused Private Method&lt;/b&gt;: Unused Private Method detects when a private method is declared but is unused.&lt;/p&gt; &lt;p&gt;Example(s):&lt;/p&gt;  &lt;pre class=&quot;sourcemeter-example-code&quot;&gt;  public class Something {&amp;#x0A;  &amp;nbsp; private void foo() {} // unused&amp;#x0A;  }&amp;#x0A;  &lt;/pre&gt;</HelpText>
        <WarningText>Avoid unused private methods.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_USBFSA">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Optimization Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Use String Buffer For String Appends</DisplayName>
        <Description>Prefer StringBuffer over += for concatenating strings.</Description>
        <HelpText>&lt;p&gt;The use of the ‘+=’ operator for appending strings causes the JVM to create and use an internal StringBuffer. If a non-trivial number of these concatenations are being used then the explicit use of a StringBuilder or threadsafe StringBuffer is recommended to avoid this.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;public class Foo {&#x0A;&#x0A;  void bar() {&#x0A;    String a;&#x0A;    a = &amp;quot;foo&amp;quot;;&#x0A;    a += &amp;quot; bar&amp;quot;;&#x0A;    // better would be:&#x0A;    // StringBuilder a = new StringBuilder(&amp;quot;foo&amp;quot;);&#x0A;    // a.append(&amp;quot; bar&amp;quot;);&#x0A;  }&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Prefer StringBuffer over += for concatenating strings.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Major</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_UnI">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Type Resolution Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Unused Imports</DisplayName>
        <Description>Avoid unused imports.</Description>
        <HelpText>&lt;p&gt;Avoid unused import statements. This rule will find unused on demand imports, i.e. import com.foo.*&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;import java.io.*; // not referenced or required&#x0A;&#x0A;public class Foo {}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid unused imports.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_UsP">
    <Configuration name = "Default">
      <Enabled>false</Enabled>
      <Group>false</Group>
      <GroupMember>Basic Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Useless Parentheses</DisplayName>
        <Description>Useless parentheses.</Description>
        <HelpText>Useless parentheses should be removed.&lt;br&gt;Example(s):&lt;br&gt;&lt;pre class=&quot;sourcemeter-example-code&quot;&gt;&#x0A;    &#x0A;public class Foo {&#x0A;&#x0A;   private int _bar1;&#x0A;   private Integer _bar2;&#x0A;&#x0A;   public void setBar(int n) {&#x0A;      _bar1 = Integer.valueOf((n)); // here&#x0A;      _bar2 = (n); // and here&#x0A;   }&#x0A;&#x0A;}&#x0A;    &#x0A;    &lt;/pre&gt;</HelpText>
        <WarningText>Useless parentheses.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "FH_WLMUB">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Group>false</Group>
      <GroupMember>Brace Rules</GroupMember>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>While Loops Must Use Braces</DisplayName>
        <Description>Avoid using &apos;while&apos; statements without curly braces.</Description>
        <HelpText>&lt;p&gt;Avoid using ‘while’ statements without using braces to surround the code block. If the code formatting or indentation is lost then it becomes difficult to separate the code being controlled from the rest.&lt;/p&gt;&#x0A;&lt;p&gt;Example(s):&lt;/p&gt;&#x0A;&lt;pre class=&quot;java&quot;&gt;&lt;code&gt;while (true) // not recommended&#x0A;  x++;&#x0A;while (true) { // preferred approach&#x0A;  x++;&#x0A;}&lt;/code&gt;&lt;/pre&gt;&#x0A;</HelpText>
        <WarningText>Avoid using &apos;while&apos; statements without curly braces.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Java Logging Rules">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Java Logging Rules</DisplayName>
        <Description>The Java Logging ruleset contains a collection of rules that find questionable usages of the logger.</Description>
        <HelpText>The Java Logging ruleset contains a collection of rules that find questionable usages of the logger.</HelpText>
        <WarningText>The Java Logging ruleset contains a collection of rules that find questionable usages of the logger.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Migration Rules">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Migration Rules</DisplayName>
        <Description>Contains rules about migrating from one JDK version to another. Don&apos;t use these rules directly, rather, use a wrapper ruleset such as migrating_to_13.xml.</Description>
        <HelpText>Contains rules about migrating from one JDK version to another. Don&apos;t use these rules directly, rather, use a wrapper ruleset such as migrating_to_13.xml.</HelpText>
        <WarningText>Contains rules about migrating from one JDK version to another. Don&apos;t use these rules directly, rather, use a wrapper ruleset such as migrating_to_13.xml.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Naming Rules">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Naming Rules</DisplayName>
        <Description>The Naming Ruleset contains rules regarding preferred usage of names and identifiers.</Description>
        <HelpText>The Naming Ruleset contains rules regarding preferred usage of names and identifiers.</HelpText>
        <WarningText>The Naming Ruleset contains rules regarding preferred usage of names and identifiers.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Optimization Rules">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Optimization Rules</DisplayName>
        <Description>These rules deal with different optimizations that generally apply to best practices.</Description>
        <HelpText>These rules deal with different optimizations that generally apply to best practices.</HelpText>
        <WarningText>These rules deal with different optimizations that generally apply to best practices.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Security Code Guideline Rules">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Security Code Guideline Rules</DisplayName>
        <Description>These rules check the security guidelines from Sun, published at http://java.sun.com/security/seccodeguide.html#gcg.</Description>
        <HelpText>These rules check the security guidelines from Sun, published at http://java.sun.com/security/seccodeguide.html#gcg</HelpText>
        <WarningText>These rules check the security guidelines from Sun, published at http://java.sun.com/security/seccodeguide.html#gcg.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Strict Exception Rules">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Strict Exception Rules</DisplayName>
        <Description>These rules provide some strict guidelines about throwing and catching exceptions.</Description>
        <HelpText>These rules provide some strict guidelines about throwing and catching exceptions.</HelpText>
        <WarningText>These rules provide some strict guidelines about throwing and catching exceptions.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "String and StringBuffer Rules">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>String and StringBuffer Rules</DisplayName>
        <Description>These rules deal with different issues that can arise with manipulation of the String, StringBuffer, or StringBuilder instances.</Description>
        <HelpText>These rules deal with different issues that can arise with manipulation of the String, StringBuffer, or StringBuilder instances.</HelpText>
        <WarningText>These rules deal with different issues that can arise with manipulation of the String, StringBuffer, or StringBuilder instances.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Type Resolution Rules">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Type Resolution Rules</DisplayName>
        <Description>These are rules which resolve java Class files for comparison, as opposed to a String.</Description>
        <HelpText>These are rules which resolve java Class files for comparison, as opposed to a String</HelpText>
        <WarningText>These are rules which resolve java Class files for comparison, as opposed to a String.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
  <Metric id = "Unnecessary and Unused Code Rules">
    <Configuration name = "Default">
      <Enabled>true</Enabled>
      <Visible>true</Visible>
      <Group>summarized</Group>
      <Language lang = "eng">
        <Warning>true</Warning>
        <DisplayName>Unnecessary and Unused Code Rules</DisplayName>
        <Description>The Unnecessary and Unused Ruleset contains a collection of rules for unnecessary,unused or ineffective code.</Description>
        <HelpText>The Unnecessary and Unused Ruleset contains a collection of rules for unnecessary,unused or ineffective code.</HelpText>
        <WarningText>The Unnecessary and Unused Ruleset contains a collection of rules for unnecessary,unused or ineffective code.</WarningText>
      </Language>
      <Baselines/>
      <Settings>
        <Setting name = "Priority" editable = "true">Minor</Setting>
      </Settings>
      <Calculated/>
    </Configuration>
  </Metric>
</Rul>
